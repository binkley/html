<style>
    article {
        counter-reset: footnotes;
    }

    a[aria-describedby="footnote-label"] {
        counter-increment: footnotes;
        text-decoration: none;
        color: inherit;
        cursor: default;
        outline: none;
    }

    a[aria-describedby="footnote-label"]::after {
        content: counter(footnotes);
        vertical-align: super;
        font-size: smaller;
        margin-left: 2px; /* TODO: Scalable? Percentage? And following... */
        color: #0000EE;
        text-decoration: underline;
        cursor: pointer;
    }

    a[aria-describedby="footnote-label"]:focus::after {
        outline: thin dotted;
        outline-offset: 2px;
    }
</style>
<article>
    <section id="caution">
        <p>(I talk about myself in the post more than usual. I'm expressing
            opinions more than usual, rather than observations and advice.
            <em>Caveat lector</em>. Also, this post is <em>link-rich</em>.)
        </p>
    </section>

    <section id="the-stack">
        <h3>The stack</h3>

        <p>After reading Eric S. Raymond (<em>ESR</em>)'s posts on the
            post-"C" world, I realized that I, too, live in that world. What
            would my ideal language stack look like for 2018?</p>

        <p>For context, here are <em>ESR</em>'s posts I have in mind:</p>

        <ol>
            <li><a href="http://esr.ibiblio.org/?p=7711"
                   title="The long goodbye to C"><cite>The long goodbye to
                C</cite></a></li>
            <li><a href="http://esr.ibiblio.org/?p=7724"
                   title="The big break in computer languages"><cite>The big
                break in computer languages</cite></a></li>
            <li><a href="http://esr.ibiblio.org/?p=7745"
                   title="Language engineering for great justice"><cite>Language
                engineering for great justice</cite></a></li>
            <li><a href="http://esr.ibiblio.org/?p=7804"
                   title="C, Python, Go, and the Generalized Greenspun Law"><cite>C,
                Python, Go, and the Generalized Greenspun Law</cite></a></li>
        </ol>

        <p>Read them? Good. So this is the language stack I have in mind:</p>

        <ul>
            <li id="python"><a href="https://www.python.org/"
                               title="Python is a programming language that lets you work quickly and integrate systems more effectively">Python</a><a
                    aria-describedby="footnote-label"
                    href="#fn1"></a> &mdash; By default
            </li>
            <li id="kotlin-jvm"><a href="https://kotlinlang.org/"
                                   title="Statically typed programming language for modern multiplatform applications">Kotlin</a>
                (JVM)<a aria-describedby="footnote-label"
                        href="#fn2"></a>
                &mdash; When you need it
            </li>
            <li id="go"><a href="https://golang.org/"
                           title="Go is an open source programming language that makes it easy to build simple, reliable, and efficient software">Go</a>
                &mdash; When you must
            </li>
        </ul>

        <p>Each of these languages hits a sweet spot, and displaces an earlier
            language which was itself a sweet spot of its time:</p>

        <ul>
            <li>Bash and Perl<a aria-describedby="footnote-label"
                                href="#fn3"></a> &rarr;
                <strong>Python</strong></li>
            <li>Java &rarr; <strong>Python and Kotlin</strong></li>
            <li>"C" and C++ &rarr; <strong>Kotlin and Go</strong></li>
        </ul>

        <p>An interesting general trend here: Not just replace a language with
            a more modern equivalent, but also move programming further away
            from the hardware. As <em>ESR</em> points out, Moore's law and
            improving language engineering have raised the bar.</p>

        <p>(<em>ESR</em>'s thinking has <a
                href="http://www.catb.org/esr/writings/taoup/html/ch14s04.html"
                title="The Art of Unix Programming, Chapter 14, Section 4, Language Evaluations">evolved
            over time</a>, a sign of someone who has given deep and sustained
            thought to the subject.)</p>
    </section>

    <section id="about-my-experience-with-these-languages">
        <h3>About my experience with these languages</h3>

        <h4>Python</h4>

        <p>I have moderate experience in Python spread out since the
            mid-90s. At that time, I was undecided between Python, Ruby
            and Perl. Over my career I worked heavily in Perl (it paid
            well, then), some in Ruby (mostly at ThoughtWorks), and
            gravitated strongly to Python, especially after using it
            at Macquarie commodities trading where it was central to their
            business.</p>

        <h4>Kotlin</h4>

        <p>I've been a Kotlin fan since it was announced. It scratches itches
            that Java persistently gives, and JetBrains is far more
            pleasant a <a
                    href="https://en.wikipedia.org/wiki/Benevolent_dictator_for_life">"benevolent
                dictator"</a> than Oracle: JetBrains continually sought input
            and feedback from the community in designing the language, for
            example. Java has been my primary language since the late 90s,
            bread and butter in most projects. If JetBrains keeps Kotlin in
            its current directions, I expect it to displace Java, and
            deservedly so.</p>

        <h4>Go</h4>

        <p>This is where I am relying on the advice of others more than
            personal experience. I started programming with "C" and LISP
            (Emacs), and quickly became an expert (things being relative) in
            C++. Among other C++ projects, I implemented for INSO (Microsoft
            Word multilingual spell checker) a then new specification for
            UNICODE/CJKV support in C++ (<a
                    href="http://www.cplusplus.com/reference/string/wstring/"><code>wstring</code></a>
            and friends). I still love "C" but could do without C++. Go seems
            to be the right way to head, especially with garbage collection.
        </p>

        <p>With <a
                href="https://www.amazon.com/Lions-Commentary-Unix-John/dp/1573980137"
                title="How I learned the kernel">Ken Thompson</a> and <a
                href="https://www.amazon.com/Unix-Programming-Environment-Prentice-Hall-Software/dp/013937681X"
                title="How I learned the command line">Rob Pike</a> behind
            it, intelligent luminaries like <em>ESR</em> pitching for it, and
            colleagues at ThoughtWorks excited to start new Go projects, it's
            high time I make up this gap.</p>
    </section>

    <section id="what-makes-a-modern-language">
        <h3>What makes a "modern" language?</h3>

        <p>I'm looking for specific things in a "modern" language<a
                aria-describedby="footnote-label" href="#fn4"></a>,
            chiefly:</p>

        <section id="good-community">
            <h4>Good community</h4>

            <p>Varying and strong:</p>

            <ul>
                <li><a href="https://www.python.org/community/">Python</a>
                </li>
                <li><a href="https://kotlinlang.org/community/">Kotlin</a>
                </li>
                <li><a href="https://golang.org/help/">Go</a></li>
            </ul>

            <p>You can explore the figures <a
                    href="https://www.tiobe.com/tiobe-index/"
                    title="TIOBE Index for November 2017">at TIOBE</a> and
                <a
                        href="https://insights.stackoverflow.com/survey/2017#technology-programming-languages"
                        title="Stack Overflow Developer Survey 2017">StackOverflow</a>.
            </p>

            <p>Kotlin is the interesting case. Though low in the rankings,
                because of 100% interoperability running on the JVM, it's easy
                to <a
                        href="https://kotlinlang.org/docs/reference/java-interop.html"
                        title="Calling Java code from Kotlin">call Java from
                    Kotlin</a> and <a
                        href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html"
                        title="Calling Kotlin from Java">call Kotlin from
                    Java</a>, so the whole Java ecosystem is available to
                Kotlin natively.</p>

            <p>Further, Google <a
                    href="https://developer.android.com/kotlin/"
                    title="Kotlin and Android">fully supports Kotlin on
                Android</a> as a first-class language, so there is a wealth of
                interoperability there. (The story for iOS is more nuanced,
                with Kotlin/Native including that platform as a target but in
                progress.)</p>

            <p>Lastly, Kotlin/Native is bringing <a
                    href="https://github.com/JetBrains/kotlin-native/blob/master/LIBRARIES.md"
                    title="Kotlin/Native libraries">similar
                interoperability</a> between Kotlin and Go.</p>

            <p>(This is related to <a href="#rich-ecosystem">having a rich
                ecosystem</a>.)</p>
        </section>

        <section id="garbage-collection">
            <h4>Garbage collection</h4>

            <p>(A <a href="http://www.toves.org/books/gc/"
                     title="Garbage collection">quick primer (2011)</a> on
                garbage collection.)</p>

            <p>Among <strong>Go</strong>'s advantages over "C" and C++ is <a
                    href="https://groups.google.com/d/msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ"
                    title="Why golang garbage-collector not implement Generational and Compact gc?">solid
                garbage collection</a> out of the box<a
                    aria-describedby="footnote-label" href="#fn5"></a>,
                though Boehm <a href="http://www.hboehm.info/gc/"
                                title="A garbage collector for C and C++">a
                    valiant effort</a>. It's only been since <a
                        href="https://www.seas.harvard.edu/courses/cs252/2016fa/16.pdf"
                        title="[PDF] Origins of Garbage Collection"><em>1959</em></a>.
                No modern programmer&mdash;short of special cases&mdash;should
                manually manage memory.</p>

            <p><strong>Kotlin</strong> gets a head start here. It's built
                on the JVM (when targeting that environment), which has
                arguably the world's greatest GC (or at least most tested).
                It definitely gives you <a
                        href="https://blog.takipi.com/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/"
                        title="Garbage Collectors - Serial vs. Parallel vs. CMS vs. G1 (and what’s new in Java 8)">a
                    choice of garbage collectors</a>. There's too much to
                say about GC on the JVM for this post except that it is
                first-rate.</p>

            <p><strong>Python</strong> has garbage collection. Though not
                as strong as the JVM, it <a
                        href="https://www.python.org/dev/peps/pep-0556/"
                        title="PEP 556 -- Threaded garbage collection">continues
                    to improve</a>. It is unusual for GC to become a limiting
                factor in a Python program; <a
                        href="https://engineering.instagram.com/dismissing-python-garbage-collection-at-instagram-4dca40b29172"
                        title="Dismissing Python Garbage Collection at Instagram">you
                    will know if it does</a>.</p>

            <p>(If you are in "C" or C++, and want some of the benefits of
                GC, do consider
                <a href="http://www.hboehm.info/gc/">the Boehm-Demers
                    -Weiser garbage collector</a>. No, you won't get the
                fullest benefits of a language built for GC, but you'll get
                enough to help a lot, even if just for leak detection.)</p>
        </section>

        <section id="static-type-inference">
            <h4>Static type inference</h4>

            <p><strong>Kotlin</strong> really demonstrates where Java could
                improve by leaps rather than <a
                        href="http://openjdk.java.net/jeps/286"
                        title="JEP 286: Local-Variable Type Inference">baby
                    steps</a>: automatic type inference. At least Java is
                heading in the right direction. Don't tell the computer <em>how</em>
                to run your program when it can figure this our for itself!
                Keep your focus on <em>what</em> the program is for.</p>

            <p>Interestingly, Kotlin and <strong>Go</strong> have strong
                typing out of the box, but not Python. <strong>Python</strong>
                has built-in support for typing, and <a
                        href="http://mypy-lang.org/"
                        title='Mypy is an experimental optional static type checker for Python that aims to combine the benefits of dynamic (or "duck") typing and static typing'>an
                    excellent optional implementation</a>, <code>mypy</code>,
                however this is <em>type declaration</em> not <em>type
                    inference</em>, so it loses a bit there. And none of the
                common alternatives (Ruby, Perl, PHP, etc.) have type
                inference either. I'll need to check again in a few years, and
                possibly update this choice.</p>

            <p>(Paul Chiusana writes <a
                    href="https://pchiusano.github.io/2016-09-15/static-vs-dynamic.html"
                    title="The advantages of static typing, simply stated">on
                the value</a> of static type checking.)</p>
        </section>

        <section id="rich-ecosystem">
            <h4>Rich ecosystem</h4>

            <p>Of the languages, <strong>Kotlin</strong> is a standout here.
                Because it is a JVM language, it is 100% compatible with
                Java, and can fully use the rich world of Java libraries
                and frameworks. The main weakness for Kotlin is lack of
                tooling: because more advanced tools may make assumptions
                about bytecode, Kotlin's particular choices of emitted
                bytecode sometimes confuse them.</p>

            <p>(JetBrains has surveyed on <a
                    href="https://www.jetbrains.com/research/devecosystem-2017/"
                    title="The State of Developer Ecosystem in 2017">the state
                of ecosystems</a> for programming languages, related to <a
                    href="#good-community">having a good community</a>.)</p>

            <p>Close behind is <strong>Python</strong>, <a
                    href="https://docs.python.org/3/tutorial/stdlib.html#batteries-included"
                    title="Brief Tour of the Standard Library">"batteries
                included"</a> and all, and it has a better organized and
                documented standard library than Java. For some problem
                domains, Python has a richer ecosystem, for example, <a
                        href="https://www.scipy.org/">SciPy</a> and <a
                        href="http://www.numpy.org/">NumPy</a> is the best
                math environment available in any language. (Some
                specialty languages like <a
                        href="https://www.mathworks.com/products/matlab.html">MATLAB</a>
                deserve mention&mdash;an early employer of mine.) I may need
                to reconsider my ranking Kotlin over Python here.</p>

            <p><strong>Go</strong> is, frankly, too new to have developed an
                equivalent ecosystem, and full-blown package management is
                still <a
                        href="https://github.com/golang/go/wiki/PackageManagementTools"
                        title="PackageManagementTools · golang/go Wiki">a
                    work in progress</a>.</p>
        </section>

        <section id="consision-and-convenience">
            <h4>Concision and convenience</h4>

            <p>A common thread in recent language development is <em>lower
                ceremony</em>: fewer punctuation marks and boilerplate; make
                the machine do more work, you do less. Kotlin provides the
                most obvious example compared to Java. Go is know for
                cleanness and brevity. And Python ranks high here as well.</p>

            <p>(Donnie Berkholz writes <a
                    href="http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/"
                    title="Programming languages ranked by expressiveness">an
                interesting post</a> on ranking language
                <em>expressiveness</em>.)</p>
        </section>
    </section>

    <section id="code-samples">
        <h3>Code samples</h3>

        <p>The classic "Hello, World!" showing three things:</p>

        <ul>
            <li>Writing a "main" callable from the command line</li>
            <li>Using standard output to print to console</li>
            <li>String formatting to build the output message</li>
        </ul>

        <p>This doesn't, of course, give a sense of how these languages in
            their full spectrum, but does give a first taste.</p>

        <section id="java-sample">
            <h4>Java</h4>

            <p>Java in a file named <code>MyStuff.java:</code></p>

            <pre class="code">package my.stuff;

public final class MyStuff {
    public static final String LANGUAGE = "Java";

    public static void main(final String... args) {
        System.out.println(String.format("Hello, World, from %s", language));
    }
}</pre>
        </section>

        <section id="kotlin-sample">
            <h4>Kotlin</h4>

            <p>Kotlin in a file named <code>my-program.kt:</code></p>

            <pre class="code">package my.stuff

const val LANGUAGE = "Kotlin"

fun main(args: Array&lt;String&gt;) = println("Hello, World, from $LANGUAGE")</pre>
        </section>

        <section id="go-sample">
            <h4>Go</h4>

            <p>But also compare Go to C++:</p>

            <pre class="code">package main

import "fmt"

const Language = "Go"

func main() {
    fmt.Println("Hello, World, from", Language)
}</pre>
        </section>

        <section id="cpp-sample">
            <h4>C++</h4>

            <p>And C++:</p>

            <pre class="code">#include &lt;iostream&gt;

int
main()
{
  std::cout &lt;&lt; "Hello, World!" &lt;&lt; std::endl;

  return 0;
}</pre>
        </section>

        <section id="python-sample">
            <h4>Python</h4>

            <p>And for completeness, Python compared to Perl and BASH:</p>

            <pre class="code">#!/usr/bin/python

language = 'Python'

print('Hello, World, from {}'.format(language))
</pre>
        </section>
        <section id="perl-sample">
            <h4>Perl</h4>

            <p>Any Perl:</p>

            <pre class="code">#!/usr/bin/perl

use strict;
use warnings;

my $language = "Perl";

printf("Hello, World, from %s\n", $language);</pre>
        </section>
        <section id="bash-example">
            <h4>BASH</h4>

            <p>Unfairly simple:</p>

            <pre class="code">#!/bin/bash

language=BASH

echo "Hello World, from $language"</pre>
        </section>
    </section>

    <section id="see-also">
        <h3>See also</h3>

        <ul>
            <li><a href="mixing-kotlin-and-go.html"
                   title="Mixing Kotlin and Go"><cite>Mixing Kotlin and
                Go</cite></a></li>
        </ul>
    </section>

    <section id="update">
        <h3>Update</h3>

        <p>As usual, I never catch as many problems in my writing as I do
            after reading it posted publically. Many small edits, and an
            added, explicit mention of <code>wstring</code>.</p>
    </section>

    <footer id="footnotes">
        <h3 id="footnote-label">Footnotes</h3>

        <ol>
            <li id="fn1"><a
                    href="https://hackernoon.com/javascript-vs-python-in-2017-d31efbb641b4"
                    title="JavaScript vs. Python in 2017">A surprising
                take</a> on Python versus JavaScript from Michael Bolin.
            </li>

            <li id="fn2">In contrast to <em>ESR</em>'s thoughtful posts, a
                nice Steve Yegge <a
                        href="https://steve-yegge.blogspot.com/2017/05/why-kotlin-is-better-than-whatever-dumb.html"
                        title="Why Kotlin Is Better Than Whatever Dumb Language You're Using">rant
                    in favor of Kotlin</a>. (I enjoy both their writing
                styles.)
            </li>

            <li id="fn3">YMMV &mdash; I use Perl as a example, but it
                could
                be Ruby or PHP or similar. And some might prefer Node.js to
                Python (but don't: see <a href="#fn1">footnote 1</a>. The
                exact
                choice is a matter of preference: I prefer Python, and some
                would keep Ruby (for example).
            </li>

            <li id="fn4">Mike Vanier wrote <a
                    href="http://users.cms.caltech.edu/~mvanier/hacking/rants/scalable_computer_programming_languages.html"
                    title="Scalable computer programming languages">a similar
                list</a> for "scalable computer programming languages" in
                2001,
                at least for the technical elements.
            </li>

            <li id="fn5">Mike Hearn points out <a
                    href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e"
                    title="Modern garbage collection">potential
                pitfalls</a> with Go GC.
            </li>
        </ol>
    </footer>
</article>
