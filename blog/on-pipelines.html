<p>The build pipeline is a key techniques to improving software delivery. It
    provides two benefits that boost productivity and reduce risk:</p>

<ol>
    <li>Quick feedback to developers (inputs)</li>
    <li>A path to production (outputs)</li>
</ol>

<p>And it is a key component of <a
        href="https://www.infoq.com/articles/Continuous-Delivery-Maturity-Model"
        title="The Continuous Delivery Maturity Model">various maturity
    models</a>.</p>

<h3 id="pipeline-benefits">Pipeline benefits</h3>

<p>The pipeline is the principal tool in connecting work (developers, inputs)
    and value (production, outputs). Benefits include:</p>
<ul>
    <li>It provides backpressure to developers, preventing many kinds of
        problems from appearing in production.
    </li>
    <li>It acts as a gate to production, increasing the options available to
        management.
    </li>
    <li>It includes quality control elements, increasing organizational
        confidence in the delivery process.
    </li>
    <li>It provides audit and control points for good governance.</li>
</ul>

<h3 id="pipeline-shape">Pipeline shape</h3>

<p>Unlike a physical pipeline, a build pipeline is bi-directional. Developer
    work flows in towards production, and production environments flow towards
    development. Another way to express this:</p>

<blockquote><em>Code should move as fast as possible towards production, and
    development should have the most production-like environment
    possible.</em></blockquote>

<!-- @formatter:off -->
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 20"
     width="80%" style="margin: auto; display:block">
    <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="1" refY="5"
                orient="auto">
            <path d="M 0 0 L 10 5 L 0 10 z"></path>
        </marker>
    </defs>
    <text x="10" y="10" transform="rotate(-90 10 10)" font-size="10"
          style="text-anchor: middle">Dev</text>
    <text x="90" y="10" transform="rotate(90 90 10)" font-size="10"
          style="text-anchor: middle">Prod</text>
    <!-- TODO: How to calculate x/y for text? -->
    <text x="25" y="6" font-size="7">Code</text>
    <line x1="40" y1="4" x2="69" y2="4" stroke="black"
          marker-end="url(#arrow)"></line>
    <text x="60" y="19" font-size="7">Env</text>
    <line x1="60" y1="17" x2="28" y2="17" stroke="black"
          marker-end="url(#arrow)"></line>
    <rect x="10" y="0" width="80" height="20" stroke="black"
          fill="transparent"></rect>
    <line x1="10" y1="15" x2="90" y2="5" stroke="black"></line>
</svg>
<!-- @formatter:on -->

<h3 id="invest-in-your-pipeline">Invest in your pipeline</h3>

<h4 id="dos">Do</h4>

<dl>
    <dt>Fail fast</dt>

    <dt>Front-load fast stages</dt>

    <dt>Separate stages by purpose</dt>

    <dt>Emulate production as much as possible</dt>
</dl>

<h4 id="donts">Don't</h4>

<dl>
    <dt>Mix types of tests in the same stage</dt>

    <dt>Mix tooling</dt>
    <dd>As much as feasible, keeping tooling consistent among all pipeline
        stages. For example, in an F# project, use the same version of F# in
        every stage. This can be challenging when crossing environment
        boundaries, say from developer's Windows desktops to managed Linux
        VMs.
    </dd>
</dl>

<h4 id="desktop-vms">Desktop VMs</h4>

<p>When possible, developers should have an environment as production-like as
    possible. One solution is to run VMs on the development desktop that
    emulate production.</p>

<h3 id="closing-the-loop">Closing the loop</h3>

<p>Pipeline is really a feedback loop, prod back to PO</p>

<h3>Need title</h3>

<p>Dev flows left, prod flows right</p>
